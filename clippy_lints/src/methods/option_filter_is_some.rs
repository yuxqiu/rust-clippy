use clippy_config::msrvs::{Msrv, OPTION_RESULT_IS_VARIANT_AND};
use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};
use clippy_utils::source::snippet;
use clippy_utils::ty::is_type_diagnostic_item;
use rustc_ast::{BindingAnnotation, UnOp};
use rustc_errors::Applicability;
use rustc_hir::def::Res;
use rustc_hir::intravisit::{walk_expr, Visitor};
use rustc_hir::{Expr, ExprKind, HirId, Mutability};
use rustc_lint::LateContext;
use rustc_span::symbol::Ident;
use rustc_span::{sym, Span};

use super::OPTION_FILTER_IS_SOME;

pub(super) fn check<'tcx>(
    cx: &LateContext<'_>,
    expr: &'tcx rustc_hir::Expr<'_>,
    filter_recv: &'tcx rustc_hir::Expr<'_>,
    filter_arg: &'tcx rustc_hir::Expr<'_>,
    filter_span: Span,
    is_some_recv_span: Span,
    msrv: &Msrv,
) {
    // Don't lint if:

    // 1. the `expr` is generated by a macro
    if expr.span.from_expansion() {
        return;
    }

    // 2. the caller of `filter` is not `Option`
    if !is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(filter_recv), sym::Option) {
        return;
    }

    // 3. msrv doesn't meet `OPTION_RESULT_IS_VARIANT_AND`
    if !msrv.meets(OPTION_RESULT_IS_VARIANT_AND) {
        return;
    }

    // 4. the argument of `filter` is not a closure
    // - Skip if the closure is bounded to a variable as the lint needs to modify the closure. So,
    //   `expr_ty` is not used here.
    let closure = match filter_arg.kind {
        ExprKind::Closure(closure) => closure,
        _ => return,
    };

    let body = cx.tcx.hir().body(closure.body);
    let arg = body.params[0];

    // 5. the argument for the closure is type annotated
    // - When the type is inferred, arg.ty_span == arg.span
    if arg.ty_span != arg.span {
        return;
    }

    let lint_msg = "called `filter(<f>).is_some()` on an `Option` value";
    match arg.pat.kind {
        // the argument to the closure is not used
        // so, we don't need to modify the closure
        rustc_hir::PatKind::Wild => {
            span_lint_and_sugg(
                cx,
                OPTION_FILTER_IS_SOME,
                expr.span.with_lo(filter_span.lo()),
                lint_msg,
                "use",
                format!("is_some_and({})", snippet(cx, filter_arg.span, "..")),
                Applicability::MachineApplicable,
            );
        },
        // Check `&` case
        rustc_hir::PatKind::Ref(pat, Mutability::Not) => {
            span_lint_and_then(
                cx,
                OPTION_FILTER_IS_SOME,
                expr.span.with_lo(filter_span.lo()),
                lint_msg,
                |diag| {
                    let suggestions = vec![
                        (filter_span, "is_some_and".to_string()),
                        (arg.span, snippet(cx, pat.span, "..").to_string()),
                        (expr.span.with_lo(is_some_recv_span.hi()), String::new()),
                    ];
                    diag.multipart_suggestion(
                        format!("use `is_some_and(<f>)` instead"),
                        suggestions,
                        Applicability::MachineApplicable,
                    );
                },
            );
        },
        // Check no & case
        rustc_hir::PatKind::Binding(
            BindingAnnotation::NONE,
            arg_id,
            Ident {
                name: _,
                span: arg_span,
            },
            None,
        ) => {
            let arg_name = snippet(cx, arg_span, "..");
            let mut argument_collector = ArgumentCollector::new(arg_id);
            argument_collector.visit_expr(body.value);

            span_lint_and_then(
                cx,
                OPTION_FILTER_IS_SOME,
                expr.span.with_lo(filter_span.lo()),
                lint_msg,
                |diag| {
                    let mut suggestions = vec![
                        (filter_span, "is_some_and".to_string()),
                        (expr.span.with_lo(is_some_recv_span.hi()), String::new()),
                    ];

                    for deref_span in argument_collector.spans_for_deref {
                        suggestions.push((deref_span, arg_name.to_string()));
                    }
                    // TODO: Sometimes, we don't need to add the `&`.
                    for not_deref_span in argument_collector.spans_for_not_deref {
                        suggestions.push((not_deref_span, format!("(&{arg_name})")));
                    }

                    diag.multipart_suggestion(
                        format!("use `is_some_and(<f>)` instead"),
                        suggestions,
                        Applicability::MachineApplicable,
                    );
                },
            );
        },
        _ => return,
    };
}

/// This type collects the spans where
/// 1. the argument is derefed
/// 2. the argument is not derefed
struct ArgumentCollector {
    arg_id: HirId,
    spans_for_deref: Vec<Span>,
    spans_for_not_deref: Vec<Span>,
}

impl ArgumentCollector {
    fn new(arg_id: HirId) -> ArgumentCollector {
        ArgumentCollector {
            arg_id,
            spans_for_deref: Vec::default(),
            spans_for_not_deref: Vec::default(),
        }
    }
}

impl<'tcx> Visitor<'tcx> for ArgumentCollector {
    fn visit_expr(&mut self, expr: &Expr<'_>) {
        match expr.kind {
            ExprKind::Unary(UnOp::Deref, sub_expr)
                if let ExprKind::Path(qpath) = sub_expr.kind
                    && let rustc_hir::QPath::Resolved(_, path) = qpath
                    && let Res::Local(local_id) = path.res
                    && local_id == self.arg_id =>
            {
                self.spans_for_deref.push(expr.span);
            },
            ExprKind::Path(rustc_hir::QPath::Resolved(_, path))
                if let Res::Local(local_id) = path.res
                    && local_id == self.arg_id =>
            {
                self.spans_for_not_deref.push(expr.span);
            },
            _ => walk_expr(self, expr),
        }
    }
}
